<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	
	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:locale" content="en_US">
	<meta property="og:url" content="https://christoferson.github.io/">
	<meta property="og:site_name" content="christoferson.github.io">
	<meta property="og:title" content="Meta Tags Preview, Edit and Generate">
	<meta property="og:description" content="Christoferson Chua GitHub Page">

	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://christoferson.github.io/">
	<meta property="twitter:title" content="christoferson.github.io">
	<meta property="twitter:description" content="Christoferson Chua GitHub Page">
	
	<script type="application/ld+json">{
		"name": "christoferson.github.io",
		"description": "Machine Learning",
		"url": "https://christoferson.github.io/",
		"@type": "WebSite",
		"headline": "christoferson.github.io",
		"@context": "https://schema.org"
	}</script>
	
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" />
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
  
	<title>Christoferson Chua</title>
	<meta name="title" content="Christoferson Chua | GitHub Page | Machine Learning">
	<meta name="description" content="Christoferson Chua GitHub Page - Machine Learning">
	<meta name="keywords" content="Backend,Java,Spring,Aws,Python,Machine Learning">
	
	<link rel="stylesheet" href="style.css">
	
</head>
<body>

<div class="container-fluid p-5 bg-primary text-white text-center">
  <h1>Machine Learning Engineer Associate (MLA)</h1>
  
</div>


<div class="container mt-5">
	<h3 class="text-primary h4">Domain 2: ML Model Development</h3>
	<!--<p class="lh-1" style="color:#BC8E19;">Software Developer | Cloud Architect</p>-->
	<p></p>
	<div class="row">
		<div class="col-sm-12">

			<p style="color: blueviolet; font-size: 20px;"><stong>Task Statement 3.3: Use automated orchestration tools to set up continuous 
				integration and continuous delivery (CI/CD) pipelines. </stong></p>
			
			<p style="color: #0066cc;"><strong>Knowledge 1: Difference between on-demand and provisioned resources</strong></p> <p>On-demand and provisioned resources are two different approaches to allocating and managing cloud computing resources. Understanding their differences is crucial for optimizing cost and performance in cloud environments.</p> <ul> <li><strong>On-demand resources:</strong> <ul> <li>Allocated and billed based on actual usage</li> <li>Automatically scale up or down based on demand</li> <li>No upfront commitment or long-term contracts</li> <li>Ideal for unpredictable workloads or variable traffic</li> </ul> </li> <li><strong>Provisioned resources:</strong> <ul> <li>Pre-allocated and reserved for a specific period</li> <li>Fixed capacity regardless of actual usage</li> <li>Often require upfront commitment or long-term contracts</li> <li>Typically offer cost savings for predictable, steady-state workloads</li> </ul> </li> </ul> <p>Examples in AWS:</p> <ul> <li>On-demand: EC2 On-Demand Instances, DynamoDB On-Demand</li> <li>Provisioned: EC2 Reserved Instances, DynamoDB Provisioned Capacity</li> </ul> <p>When choosing between on-demand and provisioned resources, consider factors such as workload predictability, budget constraints, and performance requirements. On-demand resources offer flexibility but may be more expensive for constant usage, while provisioned resources can provide cost savings for stable, long-term workloads.</p> <p style="color: #0066cc;"><strong>Knowledge 2: How to compare scaling policies</strong></p> <p>Scaling policies determine how cloud resources adapt to changes in demand. Comparing scaling policies involves evaluating different approaches to ensure optimal performance and cost-efficiency.</p> <p>Common types of scaling policies:</p> <ul> <li><strong>Simple scaling:</strong> Adjusts capacity based on a single metric (e.g., CPU utilization)</li> <li><strong>Step scaling:</strong> Allows for more granular control by defining multiple step adjustments</li> <li><strong>Target tracking scaling:</strong> Automatically adjusts capacity to maintain a specific metric target</li> <li><strong>Scheduled scaling:</strong> Adjusts capacity based on predictable time-based patterns</li> </ul> <p>When comparing scaling policies, consider the following factors:</p> <ul> <li><strong>Responsiveness:</strong> How quickly does the policy react to changes in demand?</li> <li><strong>Precision:</strong> How accurately does the policy match capacity to actual needs?</li> <li><strong>Complexity:</strong> How difficult is it to set up and maintain the policy?</li> <li><strong>Cost-efficiency:</strong> How well does the policy optimize resource utilization and costs?</li> <li><strong>Workload characteristics:</strong> Does the policy align with the specific patterns and requirements of your application?</li> </ul> <p>Example comparison:</p> <ul> <li>For a web application with unpredictable traffic spikes, target tracking scaling might be more suitable than simple scaling, as it can maintain a specific metric (e.g., average CPU utilization) more precisely.</li> <li>For a batch processing job that runs nightly, scheduled scaling would be more appropriate than reactive policies like simple or step scaling.</li> </ul> <p style="color: #0066cc;"><strong>Knowledge 3: Tradeoffs and use cases of infrastructure as code (IaC) options (for example, AWS CloudFormation, AWS Cloud Development Kit [AWS CDK])</strong></p> <p>Infrastructure as Code (IaC) allows developers to manage and provision infrastructure using code and automation. AWS offers multiple IaC options, each with its own tradeoffs and use cases.</p> <p><strong>AWS CloudFormation:</strong></p> <ul> <li><strong>Tradeoffs:</strong> <ul> <li>Pros: Mature, widely adopted, extensive documentation</li> <li>Cons: YAML/JSON syntax can be verbose, limited programming constructs</li> </ul> </li> <li><strong>Use cases:</strong> <ul> <li>Large-scale infrastructure deployments</li> <li>Teams familiar with declarative languages</li> <li>Projects requiring strict version control of infrastructure</li> </ul> </li> </ul> <p><strong>AWS Cloud Development Kit (CDK):</strong></p> <ul> <li><strong>Tradeoffs:</strong> <ul> <li>Pros: Uses familiar programming languages (e.g., TypeScript, Python), enables code reuse</li> <li>Cons: Steeper learning curve, relatively newer with evolving best practices</li> </ul> </li> <li><strong>Use cases:</strong> <ul> <li>Development teams with strong programming skills</li> <li>Projects requiring complex logic or custom resource types</li> <li>Applications that benefit from integrating infrastructure and application code</li> </ul> </li> </ul> <p>When choosing between IaC options, consider factors such as:</p> <ul> <li>Team skills and preferences</li> <li>Project complexity and scale</li> <li>Need for custom logic or reusable components</li> <li>Integration with existing development workflows</li> </ul> <p>Example scenario: A startup with a small team of Python developers might prefer AWS CDK for its familiarity and ability to leverage existing coding skills. In contrast, a large enterprise with established CloudFormation templates and processes might stick with CloudFormation for consistency and to avoid retraining costs.</p>

			<p style="color: #0066cc;"><strong>Knowledge 4: Containerization concepts and AWS container services</strong></p> <p>Containerization is a lightweight virtualization technology that packages applications and their dependencies into isolated units called containers. Understanding containerization concepts and AWS container services is crucial for modern application development and deployment.</p> <p><strong>Key containerization concepts:</strong></p> <ul> <li><strong>Container:</strong> A standalone, executable package that includes everything needed to run a piece of software</li> <li><strong>Image:</strong> A lightweight, standalone, and executable software package that includes code, runtime, libraries, and settings</li> <li><strong>Dockerfile:</strong> A text file that contains instructions for building a Docker image</li> <li><strong>Container registry:</strong> A repository for storing and distributing container images</li> <li><strong>Orchestration:</strong> The process of automating the deployment, management, scaling, and networking of containers</li> </ul> <p><strong>AWS container services:</strong></p> <ul> <li><strong>Amazon Elastic Container Service (ECS):</strong> <ul> <li>Fully managed container orchestration service</li> <li>Supports both EC2 and Fargate launch types</li> <li>Ideal for applications that need deep integration with AWS services</li> </ul> </li> <li><strong>Amazon Elastic Kubernetes Service (EKS):</strong> <ul> <li>Managed Kubernetes service</li> <li>Provides compatibility with existing Kubernetes workloads</li> <li>Suitable for organizations already using Kubernetes or requiring multi-cloud support</li> </ul> </li> <li><strong>AWS Fargate:</strong> <ul> <li>Serverless compute engine for containers</li> <li>Works with both ECS and EKS</li> <li>Eliminates the need to manage underlying infrastructure</li> </ul> </li> <li><strong>Amazon Elastic Container Registry (ECR):</strong> <ul> <li>Fully managed container registry</li> <li>Integrates seamlessly with ECS and EKS</li> <li>Provides secure, scalable, and reliable storage for container images</li> </ul> </li> </ul> <p><strong>Benefits of containerization:</strong></p> <ul> <li>Consistency across development, testing, and production environments</li> <li>Improved resource utilization compared to traditional virtual machines</li> <li>Faster application deployment and scaling</li> <li>Enhanced portability across different computing environments</li> </ul> <p>Example use case: A microservices-based application could use ECS with Fargate for running containerized services, ECR for storing container images, and Application Load Balancer for routing traffic between services. This setup provides a scalable, manageable, and cost-effective solution for deploying and running microservices.</p> <p style="color: #0066cc;"><strong>Knowledge 5: How to use SageMaker endpoint auto scaling policies to meet scalability requirements (for example, based on demand, time)</strong></p> <p>Amazon SageMaker provides auto scaling capabilities for machine learning model endpoints, allowing them to automatically adjust the number of instances to handle varying workloads. Understanding how to use SageMaker endpoint auto scaling policies is essential for optimizing performance and cost in machine learning deployments.</p> <p><strong>Key concepts:</strong></p> <ul> <li><strong>Endpoint:</strong> A hosted model that can be invoked for real-time predictions</li> <li><strong>Auto scaling:</strong> Automatically adjusting the number of instances behind an endpoint based on traffic patterns</li> <li><strong>Scaling policy:</strong> A set of rules that determine when and how to scale the endpoint</li> </ul> <p><strong>Types of SageMaker auto scaling policies:</strong></p> <ul> <li><strong>Target tracking scaling:</strong> <ul> <li>Adjusts capacity to maintain a specific metric at a target value</li> <li>Common metrics: CPU utilization, memory utilization, invocations per instance</li> <li>Example: Maintain average CPU utilization at 70%</li> </ul> </li> <li><strong>Step scaling:</strong> <ul> <li>Allows for more granular control by defining multiple step adjustments</li> <li>Useful for complex scaling scenarios or when target tracking is not suitable</li> <li>Example: Add 2 instances when CPU utilization exceeds 70%, add 3 more when it exceeds 85%</li> </ul> </li> <li><strong>Scheduled scaling:</strong> <ul> <li>Adjusts capacity based on predictable time-based patterns</li> <li>Useful for known traffic patterns or batch processing jobs</li> <li>Example: Increase capacity during business hours and decrease during off-hours</li> </ul> </li> </ul> <p><strong>Implementing auto scaling for SageMaker endpoints:</strong></p> <ol> <li>Define the minimum and maximum number of instances for the endpoint</li> <li>Choose the appropriate scaling policy type based on your requirements</li> <li>Configure the scaling policy parameters (e.g., target value, cooldown periods)</li> <li>Apply the scaling policy to the SageMaker endpoint</li> <li>Monitor and adjust the policy as needed based on observed performance and costs</li> </ol> <p><strong>Best practices:</strong></p> <ul> <li>Start with conservative scaling thresholds and adjust based on observed behavior</li> <li>Use appropriate cooldown periods to prevent rapid scaling fluctuations</li> <li>Monitor endpoint metrics and logs to identify potential performance issues</li> <li>Consider using multiple scaling policies for complex workload patterns</li> <li>Regularly review and optimize your auto scaling configuration</li> </ul> <p>Example scenario: An e-commerce company uses a SageMaker endpoint for real-time product recommendations. They implement a target tracking scaling policy to maintain an average of 1000 invocations per instance, with a minimum of 2 instances and a maximum of 10. During holiday seasons, they add a scheduled scaling policy to proactively increase capacity during peak shopping hours.</p> <p>By effectively using SageMaker endpoint auto scaling policies, you can ensure that your machine learning models can handle varying workloads while optimizing costs and maintaining performance.</p>

		</div>
	</div>

    <hr/>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>

    <hr/>

	<div class="row">
		<div class="col-sm-12">
            
        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">
            
        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">
            
        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">
            
		</div>
	</div>

    
	<div class="row">
		<div class="col-sm-12">
			
        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>
	<br/>

	<div class="row">
		<div class="col-sm-12">

        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">

        </div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>

	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>
	<br/>
	
</div>


<br/>
<br/>
<footer class="_fixed-bottom">
<div class="container-fluid p-2 bg-primary text-white text-center">
  <h6>christoferson.github.io 2023</h6>
  <!--<div style="font-size:8px;text-decoration:italic;">about</div>-->
</div>
</footer>

</body>
</html>
